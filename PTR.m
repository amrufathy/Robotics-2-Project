function [q_c, dq_c, ddq_c, trq_c] = PTR(varargin)
% Peak Torque Reduction method
disp('PTR method')

t = varargin{1}; % time vector
q0 = varargin{2}; % initial configuration
jac = varargin{3}; % task jacobian
q = varargin{4}; % symbolic q vector
dq = varargin{5}; % symbolic dq vector
p = varargin{6}; % desired cartesian trajectory
dp = varargin{7}; % desired cartesian velocity
ddp = varargin{8}; % desired cartesian acceleration
ts = varargin{9}; % sampling timestep
M = varargin{10}; % inertia matrix of robot
c = varargin{11}; % coriolois & centrifugal terms of robot
djac = varargin{12}; % d(jac)/dt
fk = varargin{13}; % forward kinematics
tb = varargin{14}; % Nx2 vector of torque joint limits

q_c(size(q0, 2), size(t, 2)) = 0;
dq_c(size(q0, 2), size(t, 2)) = 0;
ddq_c(size(q0, 2), size(t, 2)) = 0;
trq_c(size(q0, 2), size(t, 2)) = 0;

% initial state
q_c(:, 1) = q0;
dq_c(:, 1) = [0; 0; 0];

Wm = diag(diff(tb, 1, 2)).^2; % weight matrix for optimization

for i=1:size(t, 2)
    % current state (already computed)
    qi = q_c(:, i); dqi = dq_c(:, i);
    
    % next configuration
    qi1 = qi + dqi * ts; % q_i+1
    q_c(:, i + 1) = qi1;
    
    % TODO --------------------------------------------------------------
    % optimize Q to get optimal torque
    
    Ti = sym('Ti'); % current torque
    
    % dynamic variables
    % current state
    mqi = substitute(M, q, qi); % M(qi)
    cqi = substitute(c, [q dq], [qi dqi]); % c(qi, dqi)
    dqi1 = dqi + inv(mqi) * (Ti - cqi) * ts; % dq_i+1
    
    % next state
    mqi1 = substitute(M, q, qi1); % M(q_i+1)
    cqi1 = simplify(substitute(c, [q dq], [qi1 dqi1])); % c(q_i+1, dq_i+1)
    jqi1 = substitute(jac, q, qi1); % J(q_i+1)
    ddx = ddp(:, i + 1);
    djacqi1 = simplify(substitute(djac, [q dq], [qi1 dqi1])); % dJ(q_i+1, dq_i+1)
    
    sub_A1 = ((mqi1.' * Wm * mqi1) \ jqi1.'); % inv(M' * W * M) * J'
    A = (sub_A1 / (jqi1 * sub_A1)); % A(q_i+1)
    
    % objective function (Q) and constraint
    next_torque = mqi1 * A * (jqi1 * inv(mqi1) * cqi1 - djacqi1 * dqi1) + ...
        mqi1 * A * ddx + mqi1 * A * jqi1 * inv(mqi1) * (0 - sum(tb, 2)/2) + sum(tb, 2)/2;
    
    next_bounded_torque = next_torque - sum(tb, 2)/2;
    Q = simplify(0.5 * next_bounded_torque.' * Wm * next_bounded_torque);
    
    constraint = simplify(jqi1 * (inv(mqi) * (Ti - cqi) * ts + dqi)) ... % rhs
        - dp(:, i + 1); % lhs (desired velocity)
    
    % TODO: use casadi

    % -------------------------------------------------------------------
    
    % compute optimal acceleration generated by torque
    ddq_c(:, i) = inv(mqi) * (t_opt - cqi);
    
    % compute optimal velocity at next time step
    dq_c(:, i + 1) = dqi + ddq_c(:, i) * ts;
    
    break
end

end